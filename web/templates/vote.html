<head>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"/></script>
    <script src="https://cdn.jsdelivr.net/npm/luxon@^2"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@^3"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-luxon@^1"></script>

    <style type="text/css" media="screen">
    #line1 {
        width: 1200px;
    }
    </style>
</head>
<body>
    <div id="line1">
        <canvas id="voteChart"/>
    </div>
    <script type="text/javascript">
        // String format function
        const format = (str2Format, ...args) => str2Format.replace(/(\{\d+\})/g, a => args[+(a.substr(1, a.length - 2)) || 0] );
        const timeFormat = "yy/MM/dd HH:mm:ss";  // Luxon fmt to parse incoming dates.
        const luxonOpts = {
            setZone: true,
            zone: 'UTC',
        }
        const voteChartData = {{ data }}; // JSON data injected from template
        voteChartData.map(ele => {
            ele.x = luxon.DateTime.fromFormat(ele.x, timeFormat, luxonOpts);
        });
        // Generate the chart.
        const voteChart = lineVoteChart(document.getElementById("voteChart").getContext('2d'), voteChartData);
        const periodicDelay = 120; // Seconds between polling data
        // Check for new data asynchronously every delay seconds
        setInterval(function() { periodicCheck(); }, periodicDelay * 1000)

        // Given the existing data, find a suitable unit and step size.
        // TODO: Is this needed? Test automated rescaling.
        function suitableUnit(config, chartData) {
            let currentUnit = config.scales.x.time.unit;
            let lastDate = chartData[chartData.length - 1].x
            let timeGap = lastDate.diff(chartData[0].x, ['months', 'weeks', 'days', 'hours', 'minutes']);

            let unit = 'minute';
            if (timeGap.months > 3) {
                unit = 'month'
            } else if (timeGap.weeks > 5) {
                unit = 'week'
            } else if (timeGap.days > 4) {
                unit = 'day';
            } else if (timeGap.hours > 5) {
                unit = 'hour';
            }
            console.log(format("Selecting as time unit: {0}", unit));

            config.scales.x.time.unit = unit;
        }

        // Function to generate and contain line config.
        function lineVoteChart(ele, rdata) {
            const voteData = {
                datasets: [{
                    label: "Consolidation",
                    data: rdata,
                    fill: true,
                    backgroundColor: ['rgba(255, 99, 132, 0.2)'],
                    borderColor: [ 'rgba(255, 99, 132, 1)'],
                }, {
                    label: "Consildation Votes",
                    data: rdata,
                    parsing: {
                        yAxisKey: 'cons_total'
                    },
                    fill: false,
                    backgroundColor: ['rgba(54, 162, 235, 0.2)'],
                    borderColor: ['rgba(54, 162, 235, 1)'],
                }, {
                    label: "Prep Votes",
                    data: rdata,
                    parsing: {
                        yAxisKey: 'prep_total'
                    },
                    fill: false,
                    backgroundColor: ['rgba(75, 192, 192, 0.2)'],
                    borderColor: ['rgba(75, 192, 192, 1)'],
                }]
            }

            const voteConfig = {
                legend: {
                    display: true
                },
                maintainAspectRatio: true,
                responsive: true,
                scales: {
                    x: {
                        type: 'time',
                        time: {
                            displayFormats: {
                                second: "mm:ss",
                                minutes: "mm:ss",
                                hour: "LLL d HH:mm",
                                day: "LLL d HH",
                                week: "LLL d, y",
                                month: "LLL d, y",
                            },
                            unit: 'hour'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            text: "Consolidation %",
                        },
                        min: 0,
                        max: 100
                    }
                },
                plugins: {
                    title: {
                        display: true,
                        text: "Hudson Consolidation Vote"
                    },
                    tooltip: {
                        enabled: true,
                        callbacks: {
                            label: function(ctx) {
                                if (ctx.dataset.label == 'Consolidation') {
                                    return format("{0} Cons: {1} Preps: {2}", ctx.raw.y, ctx.raw.cons_total, ctx.raw.prep_total)
                                } else {
                                    return ctx.formattedValue;
                                }
                            }
                        }
                    }
                }
            }
            suitableUnit(voteConfig, voteChartData);

            return new Chart(ele, {
                type: 'line',
                data: voteData,
                options: voteConfig,
            })
        }

        // Take in new data, ensure it is in fact newer than last data in chart.
        function updateData(chart, chartData, newData) {
            newData.map(ele => {
                ele.x = luxon.DateTime.fromFormat(ele.x, timeFormat, luxonOpts);
            });

            for (let i = 0; i < newData.length; i++) {
                const lastDate = chartData[chartData.length - 1].x
                if (newData[i].x > lastDate) {
                    chartData.push(newData[i]);
                }
            }

            suitableUnit(chart.options, chartData);
            chart.update();
        }

        // Run this function periodically to check for new data on chart.
        function periodicCheck() {
            const timestamp = voteChartData[voteChartData.length - 1].x.toSeconds();

            fetch("data/vote/" + timestamp).then(function(data) {
                return data.json();
            }).catch(function(error) {
                console.log(error)
            })
            .then(newData => {
                updateData(voteChart, voteChartData, newData);
            });
        }
    </script>
</body>
